<repeat-for-each>
    <script>
      const riot = require('riot')
      import StdComp from 'Framework/app-core/StdComp'
      const sc =  Object.assign({
        preStdOnMounted(props, state) {
          this.childSlots = null;
          this.render(props)
          this.com.model.bind(this.riot, 'planet', 'fact', (comp, prop, value, old) => {
            console.warn('fact binding fires ', comp, prop, value, old)
            clearTimeout(this._once)
            this._once = setTimeout(() => {
                this.render(props)
            }, 100)

          })
        },
        render(props) {
          // console.log('RENDERING --- ')
          const vars = {}
          if (this.com) {
            Object.getOwnPropertyNames(props).forEach(p => {
              try {
                vars[p] = this.com.evaluateBindExpression(props[p], true).value
                this.com.bindComponent2(props)
              } catch (e) {}
            })
          }
          // clear all children / collect slot children
          if(!this.childSlots) {
            this.childSlots = collectChildSlots(this)
          }
          console.log('>> collected slots', this.slots)
          // clear all children
          this.root.innerHTML = '';
          const subject = vars.subject
          const slots = this.childSlots
          if(slots) {
            for (let item of subject) {
              for (let c of slots) {
                let cname = c.html.substring(1, c.html.indexOf(' '))
                let cprops = {}
                let bindings = c.bindings
                for (let bc of bindings) {
                  for (let a of bc.attributes) {
                    let com = this.com;
                    const scope = {
                      b (arg) {
                        let ok= true;
                        let rt;
                        try { rt = com.evalInnerExpression(arg,vars) } catch(e) { rt = e.toString(); ok = false; console.error(e) }
                        if(ok) try { rt = eval(rt) } catch(e) {}
                        return rt
                      }
                    }
                    cprops[a.name] = a.evaluate(scope)
                  }
                }
                // console.log('>>> creating cc from ', cname, cprops)
                let cc = document.createElement(cname)
                let cmp = riot.mount(cc, cprops)[0]
                this.root.appendChild(cc)
              }
            }
          }
        }
      }, StdComp)
      // gather the slot child hierarchy
      function collectChildSlots(pView) {
        let pname = pView.constructor.name
        console.warn('collectChildSlots for ', pname)
        const slots = []
        let n = pView.getChildrenCount()
        while (--n >=0) {
          let ch = pView.getChildAt(n)
          let cname = ch.constructor.name
          console.log('> ${cname} is a child of ${pname}')
          collectChildSlots(ch)
          let cprops = {}
          for(let p of Object.getOwnPropertyNames(ch)) {
            if(p.charAt(0) === '_' || ignoreProps.indexOf(p) !== -1) continue
            let v = ch.get(p)
            if(typeof v === 'string' || typeof v === 'number') {
              cprops[p] = ''+v
            }
          }
          // console.log('adding slot', ch, cprops)
          pname = pView.constructor.name
          cname = ch.constructor.name
          console.log('> adding ${cname} as a child of ${pname} with props', cprops)
          slots.push({parent: pView, view:ch, props:cprops})
        }
        return slots
      }
      export default sc
    </script>

</repeat-for-each>